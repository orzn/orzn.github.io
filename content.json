{"meta":{"title":"orzn","subtitle":"兴趣使然","description":"望你走出半生，归来仍是少年","author":"John Doe","url":"http://orzn.github.io"},"pages":[],"posts":[{"title":"java序列化须知","slug":"java-serializable","date":"2018-07-11T11:57:10.000Z","updated":"2018-07-12T15:00:28.365Z","comments":true,"path":"2018/07/11/java-serializable/","link":"","permalink":"http://orzn.github.io/2018/07/11/java-serializable/","excerpt":"","text":"子类父类 若父类实现了Serializable，子类不需要实现Serializable即可实现序列化。反之，父类未实现，子类实现了，序列化时，不会序列化父类的属性。如果父类不实现序列化，就必须有默认的无参构造函数，否则子类在继承Serializable接口后会报错。若想序列化父类的属性，需要自己实现writeObject(ObjectOutputStream out)和readObject(ObjectInputStream in)。如下：12345678private void writeObject(java.io.ObjectOutputStream out) throws IOException&#123; out.defaultWriteObject();//先序列化对象 out.writeInt(supervalue);//再序列化父类的域 &#125; private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; in.defaultReadObject();//先反序列化对象 supervalue=in.readInt();//再反序列化父类的域&#125; 这样在序列化时就会被调用，以代替默认的行为。 静态变量 java序列化时不会序列化静态变量，因为其属于类，不属于对象。 Externalizable接口 还有个Externalizable接口，其与Serializable接口类似，只是Externalizable接口需要强制自定义序列化。如下：123456789@Overridepublic void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(new StringBuffer(name).reverse()); //将name简单加密&#125;@Overridepublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; name = ((StringBuffer) in.readObject()).reverse().toString();&#125; 单例模式 序列化可能会破坏单例模式，解决方法有两个： 一个加readResolve 一个是用枚举方法实现单例 123456789101112131415161718public class Singleton implements Serializable&#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; private Object readResolve() &#123; return singleton; &#125;&#125; 使用枚举类实现单例模式，在对枚举类进行序列化时，还不需要添加readRsolve方法就可以避免单例模式被破坏。12345678910111213public enum SingletonClass implements Serializable &#123; INSTANCE; private static final long serialVersionUID = 1L; private String name; public void test() &#123; System.out.println(&quot;The Test!&quot;); &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name;&#125; 枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。因此，《Effective Java》作者推荐使用的方法。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://orzn.github.io/tags/java/"},{"name":"serializable","slug":"serializable","permalink":"http://orzn.github.io/tags/serializable/"}]},{"title":"CDN","slug":"CDN","date":"2018-07-10T15:04:00.000Z","updated":"2018-07-10T15:38:59.905Z","comments":true,"path":"2018/07/10/CDN/","link":"","permalink":"http://orzn.github.io/2018/07/10/CDN/","excerpt":"","text":"因为在公司项目代码里看到了CDN，对此也不了解，遂记之。 CDN，全称Content Delivery Network，内容分发网络。是将网站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。当用户访问某网站时，url经服务器解析获取对应cname域名，而这里的cname指向的是CDN负载均衡设备的IP地址。该服务器会为用户选择一台合适的缓存服务器，用户向该服务器发出请求。若此服务器没有缓存用户想要的内容，会向上一级请求，并将内容拉到本地。流程如下图： 先这样。","categories":[],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://orzn.github.io/tags/CDN/"}]},{"title":"tomcat与resin","slug":"tomcat-resin-web容器","date":"2018-07-07T04:27:07.000Z","updated":"2018-07-07T10:28:42.521Z","comments":true,"path":"2018/07/07/tomcat-resin-web容器/","link":"","permalink":"http://orzn.github.io/2018/07/07/tomcat-resin-web容器/","excerpt":"","text":"Tomcat是Apache鼎力支持的Java Web应用服务器，由于有了Sun的参与和支持，最新的Servlet和JSP规范总是能在Tomcat中得到体现，而且性能稳定，免费，又由于它优秀的稳定性以及丰富的文档资料，广泛的使用人群，从而在开源领域受到最广泛的青睐。 Tomcat运行时占用的系统资源小，扩展性好，支持负载平衡与邮件服务等开发应用系统常用的功能；而且它还在不断的改进和完善中，任何一个感兴趣的程序员都可以更改它或在其中加入新的功能。 Resin也仅仅是一个Servlet容器，然而由于它优秀的运行速度，使得它在轻量级Java Web领域备受喜爱，特别是在互联网Web服务领域，众多知名公司都采用其作为他们的Java Web应用服务器，譬如163、ku6等。 Resin也可以和许多其他的WEB服务器一起工作，比如Apache server和IIS等。Resin支持负载平衡（Load balancing），可以增加WEB站点的可靠性。方法是增加服务器的数量。比如一台SERVER的错误率是1%的话，那么支持负载平衡的两个Resin服务器就可以使错误率降到0.01%。 总的来说，有这么几个区别： resin速度快 resin报错十分简洁明确 resin对中文支持好 resin支持自动编译Servlet和bean tomcat还不支持j2ee，至少在6以前还是这样的。","categories":[],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://orzn.github.io/tags/tomcat/"},{"name":"resin","slug":"resin","permalink":"http://orzn.github.io/tags/resin/"},{"name":"web容器","slug":"web容器","permalink":"http://orzn.github.io/tags/web容器/"}]},{"title":"MongoDB入门","slug":"MongoDB-1","date":"2018-06-30T07:36:20.000Z","updated":"2018-06-30T18:55:55.176Z","comments":true,"path":"2018/06/30/MongoDB-1/","link":"","permalink":"http://orzn.github.io/2018/06/30/MongoDB-1/","excerpt":"","text":"1、相关基本概念 MongoDB 是一个基于分布式文件存储的数据库。由 C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 RDBMS NoSQL 高度组织化结构化数据 没有预定义的模式 结构化查询查询语言 没有声明性查询语言 严格的一致性 最终一致性，非ACID属性 基础事务 高性能，高可用性和可伸缩性 数据和关系存储在单独的表中 键值对存储，列存储，文档存储，图形数据库。 上面是关系型数据库和非关系型数据库的一些特点对比，有些也不是很对应，看看就好。MongoDB是个分布式文件存储结构，也满足CAP定理。 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 NoSQL的优点： 高可扩展性 分布式计算 低成本 架构的灵活性，半结构化数据 没有复杂的关系 缺点： 没有标准化 有限的查询功能（so far） 最终一致是不直观的程序 在这儿对一些常用的NoSQL数据库进行总结： 类型 代表 特点 列存储 Hbase Cassandra 顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。 键值对存储 Redis MemcacheDB 可以通过key快速查询到其value，存储和不管value的格式 图存储 Neo4J FlockDB 图形关系的最佳存储，使用传统关系数据库来解决的话性能低下 文档存储 MongoDB CouchDB 文档存储一般用类似json的格式存储，内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。 对象存储 db4o Versant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 xml数据库 Berkeley DB 高效的存储XML数据，并支持XML的内部查询语法，如XQuery, Xpath。 2、MongoDB简介 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于JSON对象。字段值可以包含其他文档，数组及文档数组。 MongoDB 安装完成后，通过MongoDB Shell来对MongoDB进行操作和管理，当./mongo进入后台后，它默认会链接到test文档（数据库）。 MongoDB概念 SQL术语 MongoDB术语 解释 database database 数据库 table collection 数据库表/集合 row document 数据库记录行/文档 colume field 数据字段/域 index index 索引 table joins 表连接，MongoDB不支持 primary key primary key 主键，MongoDB自动将_id字段设置为主键 通过下图实例，我们也可更直观的了解Mongo中的一些概念： 数据库 一个mongoDB中可以建立多个数据库，MongoDB的默认数据库为db。MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。 show dbs 命令可以显示所有数据库库的列表 db 显示当前数据库对象或集合 use 数据库名 连接到一个指定的数据库 mongodb中有一些保留的数据库名。 admin： 当Mongod启用auth选项时，用户需要创建数据库帐号，访问时根据帐号信息来鉴权，而数据库帐号信息就存储在admin数据库下。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合. config：当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 文档 文档，即一条记录，通常意义上的一行数据。MongoDB的文档不需要设置相同的字段，相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。 集合 集合就是 MongoDB 文档组，即表。集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。比如，我们可以将以下不同数据结构的文档插入到集合中： {“site”:”www.baidu.com”}{“site”:”www.google.com”,”name”:”Google”}{“site”:”www.runoob.com”,”name”:”菜鸟教程”,”num”:5} 集合名不能为空，不能含有\\0字符，这个字符表示集合名的结尾，集合不能以“system”开头，这是系统保留字符。集合中有个Capped collections，即固定大小的collection。它有很高的性能以及队列过期的特性。它非常适合类似记录日志的功能 和标准的collection不同，你必须要显式的创建一个capped collection， 指定一个collection的大小，单位是字节。collection的数据存储空间值提前分配的。1db.createCollection(&quot;mycoll&quot;, &#123;capped:true, size:100000&#125;) capped collections不允许删除文档（行），但可以drop()掉所有行。 元数据 数据库的一些信息。它们使用了系统的命名空间：dbname.system.*。 集合命名空间 描述 dbname.system.namespaces 列出所有名字空间 dbname.system.indexes 列出所有索引 dbname.system.profile 包含数据库概要信息 dbname.system.users 列出所有可访问数据库的用户 dbname.local.sources 包含复制对端（slave）的服务器信息和状态。 数据类型 String,Integer,Boolean,Double,Min/Max keys（将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。）,Array（将数组或列表或多个值存储为一个键）,Timestamp（记录文档修改或添加的具体时间）,Object（用于内嵌文档）,Null,Symbol（该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。）,Date,Object ID（对象 ID。用于创建文档的 ID。）,Binary Data（二进制数据。用于存储二进制数据。）,Code（代码类型。用于在文档中存储 JavaScript 代码。）,Regular expression（正则表达式类型。用于存储正则表达式。）。 时间戳要用于 MongoDB 内部使用。在大多数情况下的应用开发中，你可以使用 BSON 日期类型。日期，表示当前距离 Unix新纪元（1970年1月1日）的毫秒数。日期类型是有符号的, 负数表示 1970 年之前的日期。 3、基本操作12345678910111213141516171819202122232425262728use test //创建test数据库或切换此数据库db.test.insert(&#123;&quot;name&quot;:&quot;小明&quot;&#125;) //插入数据，若集合test不存在，会创建show dbs //只有有数据的数据库才显示db.dropDatabase() //删除当前数据库show tables //显示当前数据库中的集合（表）db.collection.drop() //删除集合collectiondb.createCollection(name,options) //name是集合名称 db.createCollection(&quot;mycol&quot;, &#123; capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125; ) //指定capped，必须设定size, max指集合中包含文档的最大数量。db.col.insert(&#123;title: &apos;MongoDB 教程&apos;, description: &apos;MongoDB 是一个 Nosql 数据库&apos;, by: &apos;菜鸟教程&apos;, url: &apos;http://www.runoob.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100&#125;) //col是集合，若集合不在数据库中，会自动创建该集合并插入文档db.col.find() //读取文档db.col.update(&#123;&apos;title&apos;:&apos;MongoDB 教程&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;MongoDB&apos;&#125;&#125;) //更新titledb.col.save(&#123; &quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;), &quot;title&quot; : &quot;MongoDB&quot;,&#125;) //更新此id的数据db.col.remove(&#123;&apos;title&apos;:&apos;MongoDB 教程&apos;&#125;) //删除db.col.remove(&#123;&#125;) //删除所有//条件操作符 &gt; $gt ; &lt; $lt ; &gt;= $gte ; &lt;= $lte db.col.find(&#123;&quot;likes&quot; : &#123;$gt : 100&#125;&#125;) db.col.find(&#123;likes : &#123;$lt :200, $gt : 100&#125;&#125;)db.col.find(&#123;$or:[&#123;&quot;by&quot;:&quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty() //$or就是ordb.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty()","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://orzn.github.io/tags/MongoDB/"},{"name":"database","slug":"database","permalink":"http://orzn.github.io/tags/database/"}]},{"title":"protobuf和protostuff简介[转]","slug":"protobuf-serializable","date":"2018-06-08T14:32:21.000Z","updated":"2018-06-08T14:42:13.646Z","comments":true,"path":"2018/06/08/protobuf-serializable/","link":"","permalink":"http://orzn.github.io/2018/06/08/protobuf-serializable/","excerpt":"","text":"在我们的开发过程中，序列化是经常需要处理的问题，比如在做分布式访问数据时，或者是在做redis缓存存储数据时，如果我们涉及的知识面不够广的话，可能会简单的使用JDK的序列化，也即在需要序列化的类上implements Serializable接口去实现序列化，我想说的是这种方式在小系统中尚且可以用一用，如果是并发很大的系统会受到严重影响，这是由于JDK自带的序列化效率很低，不论是时间上还是空间上。我们经常使用的序列化方式还有XML和Json，说实在的我更多的是使用Json，我觉得它很方便很友好，但这些都不够好，我今天要将的是google开发的开源的序列化方案protocol buffer（简称protobuf），它的好处很多，独立于语言，独立于平台，最最重要的是它的效率相当高，用protobuf序列化后的大小是json的10分之一，xml格式的20分之一，是二进制序列化的10分之一，是不是很心动。其实我也刚接触这个好东西，写下此篇博客就当一个学习笔记吧。protobuf使用起来非常简单，它的主要流程是：我们需要自己写一个.proto文件用来描述序列化的格式，然后用protobuf提供的protoc工具将.proto文件编译成一个Java文件（protobuf官方支持很多语言：Java、C++、C#、Go、Python ，protobuf是一个开源项目，因此有很多大牛也实现了其他语言，但它们的可靠性还有待验证），最后将该Java文件引入到我们的项目中就可以使用了，当然还得引入protobuf的依赖包。 我们需要到官网下载protobuf的相应版本，我这里下载的是windows下的3.1.0版protoc-3.1.0-win32.zip 将下载好的zip解压，能看到bin目录下有一个protoc.exe的文件，等下需要用它来编译文件，我们直接在bin目录下 创建一个简单的person.proto的描述文件，内容如下： 1234567891011121314 syntax = &quot;proto3&quot;; option java_package = &quot;gudao.red.protobuf&quot;; option java_outer_classname = &quot;PersonFactory&quot;; message Person&#123; int32 id = 1; string name = 2; int32 age = 3; Addr addr = 4; &#125; message Addr&#123; string contry = 1; string city = 2; &#125; 内容非常简单，大概介绍一下：syntax = “proto3”; 我们使用proto3版协议option java_package = “gudao.red.protobuf”;编译之后生成的Java文件的包名option java_outer_classname = “PersonFactory”;编译之后生成的Java类的类名message 相当于Java中的class详细的介绍，还请自行去官网查看。 使用protoc编译上述.proto文件，生成Java类，使用如下命令完成该操作 1protoc --java_out=./src ./person.proto –java_out:生成的Java文件输出的位置，其他语言有相应的选项。这样就会在src目录下生成一个 名为PersonFactory的Java文件。 将PersonFactory.java文件引入到我们的项目中，并引入对应版本的protobuf的依赖包 写测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041 public class Client &#123; public static void main(String[] args) throws Exception &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;,3030); Person.Builder person = Person.newBuilder(); Addr.Builder addr = Addr.newBuilder(); addr.setContry(&quot;china&quot;).setCity(&quot;shenzhen&quot;); person.setId(1).setAge(12).setName(&quot;ccf&quot;); person.setAddr(addr); byte[] messageBody = person.build().toByteArray(); int headerLen = 1; byte[] message = new byte[headerLen+messageBody.length]; message[0] = (byte)messageBody.length; System.arraycopy(messageBody, 0, message, 1, messageBody.length); System.out.println(&quot;msg len:&quot;+message.length); socket.getOutputStream().write(message); &#125; &#125; ......public class Server &#123; public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub ServerSocket serverSock = new ServerSocket(3030); while(true)&#123; Socket sock = serverSock.accept(); byte[] msg = new byte[256]; sock.getInputStream().read(msg); int msgBodyLen = msg[0]; System.out.println(&quot;msg body len:&quot;+msgBodyLen); byte[] msgbody = new byte[msgBodyLen]; System.arraycopy(msg, 1, msgbody, 0, msgBodyLen); Person person = Person.parseFrom(msgbody); System.out.println(&quot;Receive:&quot;); System.out.println(person); &#125; &#125; &#125; 先后启动Server和Client，就可以看到控制台的输出如下： 至此，我们的简单使用过程就完成了，是不是很简单。是，这个例子看上去是挺简单的，但如果我们需要序列化的类非常多，那么我们是不是得写非常多的.proto文件，并且还需要更新它们，这个代价可以想象一下也是非常大的。那么，接下来我们就来讲一讲protostuff，看这名字是不是跟protobuf很像，嗯，它们是有关系，前者就是基于后者实现的。 protostuff是一个基于protobuf实现的序列化方法，它较于protobuf最明显的好处是，在几乎不损耗性能的情况下做到了不用我们写.proto文件来实现序列化。使用它也非常简单，所以直接上代码。 12345678910111213141516171819202122public class ProtostuffTest &#123; static RuntimeSchema&lt;Po&gt; poSchema = RuntimeSchema.createFrom(Po.class); private static byte[] decode(Po po)&#123; return ProtostuffIOUtil.toByteArray(po, poSchema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE)); &#125; private static Po ecode(byte[] bytes)&#123; Po po = poSchema.newMessage(); ProtostuffIOUtil.mergeFrom(bytes, po, poSchema); return po; &#125; public static void main(String[] args) &#123; InnerPo innerPo = new InnerPo(1, &quot;InnerPo1&quot;); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); Po po = new Po(1, &quot;Fong&quot;, &quot;备注&quot;, 24, new int[]&#123;1,2,3,4&#125;,innerPo,list); byte[] bytes = decode(po); System.out.println(bytes.length); Po newPo = ecode(bytes); System.out.println(newPo); &#125; &#125;","categories":[],"tags":[{"name":"serializable","slug":"serializable","permalink":"http://orzn.github.io/tags/serializable/"},{"name":"protobuf","slug":"protobuf","permalink":"http://orzn.github.io/tags/protobuf/"}]},{"title":"redis入门","slug":"redis-1","date":"2018-06-03T06:40:21.000Z","updated":"2018-06-08T14:08:20.314Z","comments":true,"path":"2018/06/03/redis-1/","link":"","permalink":"http://orzn.github.io/2018/06/03/redis-1/","excerpt":"","text":"Redis简介Redis是一个开源的，高性能的Key-Value存储系统。Redis的所有操作都是原子性的，同时还支持对几个操作合并后的原子性执行。与其他key-value缓存产品相比，还有以下三个特点： Redis支持数据持久化，可将数据保存在磁盘中，重启时再次加载进行使用。 Redis不仅仅支持简单类型数据，同时还提供了list,set,zset,hash等数据结构。 支持数据备份，即master-slave模式的数据备份。 Redis支持五种数据类型，string，hash，list，set及zset(有序集合)。 String string类型是二进制安全的，意思是string可以包含任何数据。比如jpg或者序列化后的对象。一个键最大能存储512MB。 123redis 127.0.0.1:6379&gt; SET name &quot;dd&quot;redis 127.0.0.1:6379&gt; GET name&quot;dd&quot; Hash hash即hashmap。使用HMSET，HGET命令赋值读取。 123redis 127.0.0.1:6379&gt; HMSET myhash field1 &quot;hello&quot; field2 &quot;world&quot;redis 127.0.0.1:6379&gt; HGET myhash field1&quot;hello&quot; List list是字符串列表，可用LPUSH，PPUSH在列表前后添加元素，用LRANGE获取指定范围内的元素。列表最后存储2的32次方-1个元素。 Set 用sadd进行添加，smembers查看元素集合。 zset zset中每一个元素会关联一个double类型的分数，redis通过分数为集合中的元素进行排序，分数可以重复。 1zadd key score member Java使用redis 要在Java中使用redis，需要jedis.jar。操作很简单，如下： 12345Jedis jedis = new Jedis(&quot;192.168.1.10&quot;,6379);jedis.auth(&quot;123456&quot;); //passwordjedis.set(&quot;name&quot;,&quot;jedis&quot;);String value = jedis.get(&quot;name&quot;);jedis.close(); 还可以用redisPool连接池。 12345678910111213141516171819202122232425262728 public class TestJedis &#123; public static void main(String[] args) &#123; JedisPoolConfig jpconfig= new JedisPoolConfig();//初始化连接池 jpconfig.setMaxTotal(100);//设置最大连接数 jpconfig.setMaxIdle(10);//设置最大空闲连接数 JedisPool jedisPool = new JedisPool(jpconfig,&quot;192.168.1.10&quot;,6379); Jedis jedis=null; try&#123; jedis=jedisPool.getResource(); jedis.auth(&quot;123456&quot;); jedis.set(&quot;name&quot;, &quot;Jedis Redis&quot;); String value=jedis.get(&quot;name&quot;); System.out.println(value); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; if(jedis!=null)&#123; jedis.close(); &#125; if(jedisPool!=null)&#123; jedisPool.close(); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"database","slug":"database","permalink":"http://orzn.github.io/tags/database/"},{"name":"redis","slug":"redis","permalink":"http://orzn.github.io/tags/redis/"}]},{"title":"Java-annotation简介","slug":"Java, annotation","date":"2018-06-01T12:30:01.000Z","updated":"2018-06-02T05:06:27.666Z","comments":true,"path":"2018/06/01/Java, annotation/","link":"","permalink":"http://orzn.github.io/2018/06/01/Java, annotation/","excerpt":"","text":"Java注解在之前的学习实践过程基本没有用过，但是今天碰到了，感觉还是有必要学习记录一下。 注解的定义注解通过@interface关键字进行定义。12public @interface TestAnnotation&#123;&#125; 这个形式和接口的定义很像，但是多了个@,上面的代码就定义了一个TestAnnotation。要想注解能够正常工作，还需要介绍一下新的概念那就是元注解。元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。元注解有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。 @Retention@Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。它的取值有如下三个： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译后就不存在了。如@Override。 RetentionPolicy.CLASS注解只被保留到编译进行的时候，它并不会被加载到JVM中。默认是clas。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到JVM中，所以在程序运行时可以获取到它们。 我们可以用以下两种方法指定注解：12@Retention(RetentionPolicy.RUNTIME)@Retention(value=CLASS) @Documented这个注解作用是能够将注解中的元素包含到Javadoc中去。 @Target@Target指定了注解运用的地方。 ElementType.ANNOTATION_TYPE可以给一个注解进行注解。 ElementType.CONSTRUCTOR可以给构造方法进行注解 ElementType.FIELD可以给属性进行注解 ElementType.LOCAL_VARIABLE可以给局部变量进行注解 ElementType.METHOD可以给方法进行注解 ElementType.PACKAGE可以给一个包进行注解 ElementType.PARAMETER可以给一个方法内的参数进行注解 ElementType.TYPE可以给一个类型进行注解，比如类、接口、枚举 @Inherited@Inherited表明注解类可以被继承，当类A被这样的注解修饰之后，类B继承A，则类B也拥有这个注解。接口，方法的注解不能被继承。 @Repeatable这个是Java1.8之后才有的注解。12345678910111213@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default &quot;&quot;;&#125;@Person(role=&quot;artist&quot;)@Person(role=&quot;coder&quot;)@Person(role=&quot;PM&quot;)public class SuperMan&#123;&#125; 上面的Persons是一个容器注解，就是用来存放其他注解，Person的地方。按规定，容器注解中必须有一个value数组，属性类型被@Repeatable注解过。之后，就可以用多个Person注解。 注解属性注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id(); String msg();&#125; 像上面的注解要进行复制，是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开。12@TestAnnotation(id=3,msg=&quot;hello annotation&quot;)public class Test &#123; &#125; 注解中的属性可以有默认值，需要用default关键字指定。如：1public int id() default -1; 如果只有一个变量，可以省略value=-1,直接在括号里赋值-1。没有属性时，括号都可以省略。 注解提取想要获知某一对象是否应用了某注解，可以用反射。首先可以通过 Class对象的isAnnotationPresent()方法判断它是否应用了某个注解。1public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;&#125; 然后通过 getAnnotation() 方法来获取 Annotation 对象。1public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;&#125; 或者是 getAnnotations() 方法。1public Annotation[] getAnnotations() &#123;&#125; 完整的例子如下：12345678910111213141516@TestAnnotation()public class Test &#123; @Check(value=&quot;hi&quot;) int a; @Perform public void testMethod()&#123;&#125; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println(&quot;id:&quot;+testAnnotation.id()); System.out.println(&quot;msg:&quot;+testAnnotation.msg()); &#125; &#125;&#125; 还可以用相同的方法获取变量，方法上的注解。1234567891011Field a = Test.class.getDeclaredField(&quot;a&quot;);a.setAccessible(true);//私有变量访问性必须设为true，才能访问。Check check = a.getAnnotation(Check.class);Method testMethod = Test.class.getDeclaredMethod(&quot;testMethod&quot;);if ( testMethod != null ) &#123; // 获取方法中的注解 Annotation[] ans = testMethod.getAnnotations(); for( int i = 0;i &lt; ans.length;i++) &#123; System.out.println(&quot;method testMethod annotation:&quot;+ans[i].annotationType().getSimpleName()); &#125;&#125; 使用场景官方文档中如是说： 提供信息给编译器：编译器可以利用注解来探测错误和警告信息。 编译阶段时的处理：软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。 运行时的处理：某些注解可以在程序运行的时候接受代码的提取。具体点说，在spring中有ApplicationContext.getBeansWithAnnotation()，可以得到所有有特定注解的bean集合，方便系统参数的初始化等等。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://orzn.github.io/tags/Java/"},{"name":"annotation","slug":"annotation","permalink":"http://orzn.github.io/tags/annotation/"}]},{"title":"Zookeeper初探（一）","slug":"Zookeeper-1","date":"2018-06-01T08:11:12.000Z","updated":"2018-06-02T05:18:37.760Z","comments":true,"path":"2018/06/01/Zookeeper-1/","link":"","permalink":"http://orzn.github.io/2018/06/01/Zookeeper-1/","excerpt":"","text":"概述ZooKeeper是一种分布式协调服务，其本身类似于标准文件系统。通过这个文件系统，Zookeeper提供了以下几种常见服务： 命名服务 按名称标示集群中的节点 配置管理 加入节点的最近和最新的系统配置信息 集群管理 实时的在集群和节点状态中加入/离开节点 选举算法 选举一个节点作为协调目的的leader 锁定和同步服务 在修改数据的同时锁定数据。此机制可帮助你在连接其他分布式应用程序（如Apache HBase）时进行自动故障恢复。 高度可靠的数据注册表 即使在一个或几个节点关闭时也可以获得数据。 基础系统根目录是‘/’，一个名字是一系列的以‘/’隔开的路径元素，如下图所示。 区别于标准文件系统的是，Zookeeper命名空间中的每个节点可以有数据也可以有子目录。每个节点称为znode。znode维持了一个stat结构，包括数据变化的版本号、访问控制列表变化、时间戳和数据长度。默认情况下，znode能够存储1MB的数据。每当znode的数据有变化，版本号就会增加。znode节点分为两种，永久节点和临时节点。临时节点和session存活的一样长，当session结束时，也跟着删除。在Zookeeper客户端与服务端成功完成连接创建后，就创建了一个会话。客户端以特定的时间间隔发送心跳以保持会话有效。如果ZooKeeper集合在超过服务器开启时指定的期间（会话超时）都没有从客户端接收到心跳，则它会判定客户端死机。Zookeeper支持watches的概念。客户端可以在znode上设置一个watch。当znode发生变化时触发并移除watch。当watch被触发时，客户端会接收到一个包说明znode有变化了。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。 ZAB协议ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。基于该协议，Zookeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体的，是使用了一个单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以事物Proposal的形式广播到所有的副本进程上去。另一方面，考虑到分布式环境中，顺序执行的一些状态变更其前后会存在一定的依赖关系，这样的依赖关系也对ZAB协议提出了一个要求，ZAB协议必须保证一个全局的变更序列被顺序应用。最后，考虑到主进程在任何时候都可能出现崩溃推出或重启现象，因此，ZAB协议还要在出现上述异常时，依旧能正常工作。其核心类似2pc协议： Leader服务器将一个客户端的请求转换成一个事务Proposal（提议），并将该事务发给集群中所有follower服务器。之后，leader服务器需要等待所有follower服务器反馈，若得到超过半数的正确反馈，leader就会再次向所有follower服务器分发commit消息，要求将前一个Proposal提交。 协议介绍ZAB协议包括两种基本的模式，崩溃恢复和消息广播。崩溃恢复指的是服务刚启动或者leader服务器出现崩溃退出时，要重新选举leader，同时集群中有超过半数的机器与leader完成了状态同步之后，退出恢复模式。具体我们分开讲： 消息广播在广播过程中，Leader服务器会为每个事务请求生成对应的Proposal来进行广播，并为其分配一个全局单调递增的唯一ID，称之为事务ID（即ZXID）。为了保证消息严格的因果关系，因此，必须将每一个事务Proposal按照ZXID的先后顺序来进行排序与处理。另外，整个消息广播协议是基于FIFO特性的TCP协议来进行网络通信的，因此能很容易地保证消息广播过程中消息接收与发送的顺序性。具体的，每个follower都有一个单独的队列，需要广播的事务就依次放入队列中，根据FIFO进行消息发送。每个follower接收到事务之后，都会首先以事务日志的形式写到磁盘中，写入成功后会给leader服务器一个ACK响应，leader收到过半数的ACK后，会通知所有follower进行事务提交，同时自身也完成事务提交。 崩溃恢复ZAB协议确保已经在leader服务器上提交的事务最终被所有服务器都提交，确保丢弃那些只在leader服务器上被提出的事务。为了满足这些，只需保证找到的新leader服务器拥有所有机器最大ZXID编号的事务Proposal。完成选举后，leader服务器得确认事务日志中的所有Proposal是否都已经被急集群中过半的机器提交了，即是否完成数据同步。我们先看下ZXID的设计，ZXID高32位表示leader周期epoch的编号，低32位代表每一个事务编号。都是依次加一。Leader服务器会为每一个follower准备一个队列，并将那些没有被follower同步的事务以Proposal消息的形式逐个发送，并紧接着发送一个commit消息。若这时，先前崩溃的尚未提交的事务Proposal机器恢复了，leader服务器会和其进行对比，要求follower进行回退。在服务器集群初始化阶段，leader选举就复杂一些。（1） 每个server发出投票，包含myid，ZXID。（2） 接收来自各个服务器的投票。ZXID大优先，若相同，myid大的优先。若接受了新的选票，就将新的选票发出去；若没有接受，则不处理。（3） 对投票信息进行统计，若超过半数的选票的机器即为leader节点。 未完待续。","categories":[],"tags":[{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://orzn.github.io/tags/Zookeeper/"}]},{"title":"Java-动态代理简介","slug":"Java 动态代理","date":"2018-05-31T10:40:31.000Z","updated":"2018-06-02T05:09:40.484Z","comments":true,"path":"2018/05/31/Java 动态代理/","link":"","permalink":"http://orzn.github.io/2018/05/31/Java 动态代理/","excerpt":"","text":"代理模式是常用的Java设计模式之一，而根据创建代理类的时间点，又可以分为静态代理和动态代理。他的特征是代理类和委托类继承同样的接口，代理类本身并不真正实现服务，而是负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。 静态代理就像上图所示，程序员直接创建好所有需要的代码，也就是在编译时就已经将接口，被代理类，代理类确定下来。动态代理中的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的指示动态生成的。 Java的动态代理有两种实现方法，一种是JDK动态代理，一种是CGlib。 ####1、JDK JDK方法实现InvocationHandler接口，用bind方法绑定实现类对象，invoke方法调用对象方法。举个例子： 先定义一个接口：123public interface BookFacade&#123; public void addBook();&#125; 然后，创建委托类，即真正的业务实现类：123456public class BookFacadeImpl implements BookFacade &#123; @Override public void addBook() &#123; System.out.println(&quot;增加图书方法。。。&quot;); &#125; &#125; 最后，创建动态代理类：12345678910111213141516public class BookFacadeProxy implements InvocationHandler&#123; private Object target;//委托类对象 public Object bind(Object target)&#123; this.target = target; //通过反射机制，创建一个代理类对象实例并返回，用户进行方法调用时使用 return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(), this); &#125; public Object invoke(Object proxy,Method method,Object[] args)&#123; Object result=null; System.out.println(&quot;预处理操作——————&quot;); //调用真正的业务方法 result=method.invoke(target, args); System.out.println(&quot;调用后处理——————&quot;); return result; &#125;&#125; 如何使用：123456public static void main(String[] args) &#123; BookFacadeImpl bookFacadeImpl=new BookFacadeImpl(); BookFacadeProxy proxy = new BookFacadeProxy(); BookFacade bookfacade = (BookFacade) proxy.bind(bookFacadeImpl); bookfacade.addBook(); &#125; 在代理类实现中也可以不实现bind，在main函数中执行Proxy.newProxyInstance()。这个函数的作用就是把返回的接口对象和代理类绑定在一起，当执行接口函数时，会执行代理类的invoke。 ####2、CGlib CGlib是针对类来实现代理的。代理类实现MethodInterceptor接口。 先定义一个类：12345public class BookFacadeImpl&#123; public void addBook()&#123; System.out.println(&quot;新增图书。。。&quot;); &#125;&#125; 然后创建代理类：1234567891011121314151617181920public class BookFacadeCglib implements MethodInterceptor &#123; private Object target;//业务类对象 //相当于JDK动态代理中的绑定 public Object getInstance(Object target) &#123; this.target = target; Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类 enhancer.setSuperclass(this.target.getClass()); //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类） //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦 enhancer.setCallback(this); // 创建动态代理类对象并返回 return enhancer.create(); &#125; // 实现回调方法 public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;预处理——————&quot;); proxy.invokeSuper(obj, args); //调用业务类（父类中）的方法 System.out.println(&quot;调用后操作——————&quot;); return null; &#125;&#125; 如何使用：123456public static void main(String[] args) &#123; BookFacadeImpl1 bookFacade=new BookFacadeImpl1()； BookFacadeCglib cglib=new BookFacadeCglib(); BookFacadeImpl1 bookCglib=(BookFacadeImpl1)cglib.getInstance(bookFacade); bookCglib.addBook(); &#125; PS: CGlib是一个代码生成包。除了动态代理，还提供了反射功能，据称效果更好。show the code.1234Class&lt;?&gt; clazz = x.getClass();FastClass fastClass = FastClass.create(clazz); //得到对象的fast类FastMethod faseMethod = fastClass.getMethod(methodName,parameterTypes);//输入参数名和参数类型。fastMethod.invoke(x,parameters);//执行x对象的方法 以上。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://orzn.github.io/tags/Java/"},{"name":"动态代理","slug":"动态代理","permalink":"http://orzn.github.io/tags/动态代理/"}]},{"title":"Java-AQS简介","slug":"Java AQS","date":"2018-05-31T10:39:27.000Z","updated":"2018-06-02T05:09:15.327Z","comments":true,"path":"2018/05/31/Java AQS/","link":"","permalink":"http://orzn.github.io/2018/05/31/Java AQS/","excerpt":"","text":"AQS，即AbstractQueuedSynchronizer。提供了一个基于FIFO队列，和state变量，可以用于构建锁或者其他相关同步装置的基础框架。目前我所了解到的ReentrantLock、ReadWriteLock，CountdownLatch，FutureTask等实现都依赖于AQS。 前面提到的FIFO队列，节点Node保存着线程引用和线程状态。表示每一个等待锁的线程。Node主要包含以下成员变量： 1234567Node&#123; int waitStatus; Node prev; Node next; Node nextWaiter; Thread thread;&#125; 下面通过一个排它锁这个例子来理解一下同步器的工作原理。其中，state初始化为0，表示排它锁可用，变为1表示排它锁被占用。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Mutex implements Lock, java.io.Serializable &#123; // 内部类，自定义同步器 private static class Sync extends AbstractQueuedSynchronizer &#123; // 是否处于占用状态 protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; // 当状态为0的时候获取锁 public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; // 释放锁，将状态设置为0 protected boolean tryRelease(int releases) &#123; assert releases == 1; // Otherwise unused if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; &#125; // 返回一个Condition，每个condition都包含了一个condition队列 Condition newCondition() &#123; return new ConditionObject(); &#125; &#125; // 仅需要将操作代理到Sync上即可 private final Sync sync = new Sync(); public void lock() &#123; sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; &#125; 若自己要实现同步，可像上面代码一样新建内部类Sync，继承自AQS并按需实现钩子方法。（钩子方法源于设计模式中模板方法模式，模板方法模式中分为两大类：模版方法和基本方法，而基本方法又分为：抽象方法，具体方法，钩子方法。钩子方法的实际应用为，对于一个接口，而你只想使用接口中的一个方法，那么你可以写一个抽象类实现这个接口，将那个方法设置为abstract，其它方法进行空实现，然后你再继承这个抽象类，就不需要实现其它的方法。）钩子方法 | 简介 | :-:tryAcquire (int arg) | 排他获取(资源数)tryRelease(int arg) | 排他释放(资源数)tryAcquireShared(int arg)tryAcquireShared(int arg) | 共享获取(资源数)tryReleaseShared(int arg) | 共享释放(资源数)isHeldExclusively() | 是否排他状态 方法不需要全部实现，如果像排它锁那样的，只需实现排他方法。AQS的其他方法可以直接继承使用。 那么，现在设计一个同步工具，该工具在同一时刻只能有两个线程能够并发访问，超过限制的其他线程进入阻塞状态。因为要共享资源，所以需要实现tryAcquireShared和tryReleaseShared方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class TwinsLock implements Lock &#123; private final Sync sync = new Sync(2); private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -7889272986162341211L; Sync(int count) &#123; if (count &lt;= 0) &#123; throw new IllegalArgumentException(&quot;count must large than zero.&quot;); &#125; setState(count);//设置初始state &#125; public int tryAcquireShared(int reduceCount) &#123; for (;;) &#123; int current = getState(); int newCount = current - reduceCount; //等于-1直接就无法获取锁 if (newCount &lt; 0 || compareAndSetState(current, newCount)) &#123; return newCount; &#125; &#125; &#125; public boolean tryReleaseShared(int returnCount) &#123; for (;;) &#123; int current = getState(); int newCount = current + returnCount; if (compareAndSetState(current, newCount)) &#123; return true; &#125; &#125; &#125; &#125; public void lock() &#123; sync.acquireShared(1); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; public boolean tryLock() &#123; return sync.tryAcquireShared(1) &gt;= 0; &#125; public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(time)); &#125; public void unlock() &#123; sync.releaseShared(1); &#125; @Override public Condition newCondition() &#123; return null; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://orzn.github.io/tags/Java/"},{"name":"AQS","slug":"AQS","permalink":"http://orzn.github.io/tags/AQS/"}]},{"title":"vmware tools失效","slug":"vmware","date":"2017-12-27T12:37:22.000Z","updated":"2018-05-31T16:42:59.139Z","comments":true,"path":"2017/12/27/vmware/","link":"","permalink":"http://orzn.github.io/2017/12/27/vmware/","excerpt":"","text":"不知道是因为安装了哪些东西，vmware的vmware tools突然不能用了，窗口不能自适应，也不能拖动文件进行复制。折腾了好久，open-vm-tools，vmware中的vmware-tools各种反复安装，也没卵用。后来，试了别人博客一种方法，总算成功了。ps：vmware版本10，ubuntu 是16.04。 sudo apt-get autoremove open-vm-tools Install VMware Tools by following the usual method (Virtual Machine –&gt; Reinstall VMWare Tools) Reboot the VM sudo apt-get install open-vm-tools-desktop Reboot the VM, after the reboot copy/paste and drag/drop will work!","categories":[],"tags":[{"name":"vmware","slug":"vmware","permalink":"http://orzn.github.io/tags/vmware/"}]},{"title":"javaFX初探","slug":"javaFX-1","date":"2017-08-25T08:39:07.752Z","updated":"2018-05-12T17:10:54.494Z","comments":true,"path":"2017/08/25/javaFX-1/","link":"","permalink":"http://orzn.github.io/2017/08/25/javaFX-1/","excerpt":"","text":"JavaFX是Java的下一代图形用户界面工具包。JavaFX是一组图形和媒体API，我们可以用它们来创建和部署富客户端应用程序。虽说似乎是一种衰落的丰富互联网应用技术。但是因为一些原因，前段时间要写个界面，又因为最近java搞得比较多，就打算用java撸一个出来，特此做个记录。 除了javaFX，还有swing，不过相比javaFX，swing似乎更out一些。好像很久都没更新了。 开始步入正题 开发环境配置 从Java8开始，JDK(Java开发工具包)包括了JavaFX库。因此，要运行JavaFX应用程序，您只需要在系统中安装Java8或更高版本。除此之外，IDE(如Eclipse，NetBeans和idea)为JavaFX提供支持。 为IDE配置环境，我用的idea。Eclipse和NetBeans的在百度吧，这个还是挺好找的。首先，你需要下一个JavaFX Scene Builder。这是一种可视布局工具，就是一拖控件的。不要也行，但是作为一小白，还是用吧。之后，在idea中新建一个javaFX工程，创建完之后。 按上图操作，就可以在IDE中随时打开JavaFX Scene Builder，从而更方便的编辑自己的界面。 快速入门 本部分介绍如何写程序。实际创建工程完之后，会生成一个空的helloworld。里面包含三个文件：一个Main.java,一个Controller.java，一个sample.fxml。简单的说是这样，fxml定义界面外观，Controller定义操作时调用的函数，Main毫无疑问，程序的入口，加载下fxml。不过，实际上，也可以不用fxml,完全在main中写界面，但这就麻烦了。 fxml 从fxml名字就能看出，这和html很像。html是定义内容，css定义样式。在javaFX中，也可以使用css。不过，我没有用，也不是很了解。用fxml定义样式，首先要选择各种容器，我觉得这个起到的作用类似于div，之后再在里面放入各种组件。如果要对某一组件操作，比如点击后要调用某函数，需要给它定义id。 controller controller其实比较简单，就是普通的java程序。不过需要注意的是，在里面要用到的组件，需要在前面定义一下，变量名就是id名。例如： 12@FXMLprivate Label help; FXML必须写。 main main函数其实不需要怎么动。 1234567Parent root = FXMLLoader.load(getClass().getResource(&quot;sample.fxml&quot;)); primaryStage.setTitle(&quot;Hello World&quot;); primaryStage.setScene(new Scene(root, 300, 275)); primaryStage.setResizable(false); Image image= new Image(this.getClass().getResource(&quot;icon.jpg&quot;).toString(), 100, 150, false, false); primaryStage.getIcons().add(image); primaryStage.show(); 可能会用到的常见的有两个，一个是第四行的函数来保证界面大小固定，第五行，第六行的代码是改程序的图标。 最后，是给程序打包成exe。这个可折腾了我好一会儿。首先，先打成jar包，还要把Available elements中的东西都移到output root下，里面还要写Application class，后面的要与这个一致。把jar包转成exe用到的是jdk中自带的javafxpackager。 javafxpackager -deploy -appclass Test -native image -srcdir archive -outdir deploy -outfile Test 需要改的就一个Test,和输入文件、输出文件。Test是前面输入的Application class，输入文件是jar所在位置，输出就随意了。 以上是对javaFX的一个基本介绍。","categories":[],"tags":[{"name":"javaFX","slug":"javaFX","permalink":"http://orzn.github.io/tags/javaFX/"}]},{"title":"七周七并发之函数式编程","slug":"七周七并发之二","date":"2017-08-20T14:10:20.000Z","updated":"2018-05-13T07:12:49.932Z","comments":true,"path":"2017/08/20/七周七并发之二/","link":"","permalink":"http://orzn.github.io/2017/08/20/七周七并发之二/","excerpt":"","text":"提到函数式编程，就要提到命令式编程。常见的C，Java都是命令式编程，代码由一些列改变全局状态的语句过程，而函数式编程则是将计算过程抽象成表达式求值。轮子哥是这么形容函数式语言的，“函数式语言都倾向于让你用函数来组成函数，而不是把函数看成是一个数据弄成另一个数据的过程。”函数式编程可以更容易做到线程安全，因此特别适合于并发编程。 1、抛弃可变状态 函数式编程里，没有可变状态。为了体验函数式编程，这里介绍下Clojure。Clojure是一种运行在Java平台上的 Lisp 方言，Lisp是一种以表达性和功能强大著称的编程语言，但人们通常认为它不太适合应用于一般情况，而Clojure的出现彻底改变了这一现状。如今，在任何具备 Java 虚拟机的地方，您都可以利用 Lisp 的强大功能。 Clojure代码由s-表达式过构成。可以将表达式视为带括号的列表。主流语言中的max(3,5)在Clojure中写作： 1user=&gt; (max 3 5) 数学运算符也是同样的表示方式。比如1+2*3，写成： 1user=&gt; (+ 1 (* 2 3)) 使用def可以定义常量： 1234user=&gt; (def meaning-of-life 42)#&apos;user/meaning-of-lifeuser=&gt; meaning-of-life42 控制结构也可以写成s-表达式： 12user=&gt; (if (&lt; meaning-of-life 0) &quot;negative&quot; &quot;non-negative&quot;)&quot;non-negative&quot; Clojure的大多数语句都是一个s-表达式，然而也有个别例外。矢量（数组）是用方括号表示： 12345678user=&gt; (def droids [&quot;a&quot; &quot;b&quot; &quot;c&quot;])#&apos;user/droidsuser=&gt; (count droids)3user=&gt; (droids 0)&quot;a&quot;user=&gt; (droids 2)&quot;c&quot; map是用花括号表示： 1234user=&gt; (def me &#123;:name &quot;Paul&quot; :age 45 :sex :male&#125;)#&apos;user/meuser=&gt; (:age me)45 使用defn可以定义函数，函数参数是矢量形式的： 1234user=&gt; (defn percentage [x p] (* x (/ p 100.0)))#&apos;user/percentageuser=&gt; (percentage 200 10)20.0 举个例子——词频统计 先给出代码： 12345(defn word-frequencies [words](reduce (fn [counts word] (assoc counts word (inc (get counts word 0))))&#123;&#125; words)) defn定义一个函数，所有外面有一个大括号，words是参数，里面的()就是函数体，reduce是Clojure中一个函数，需要三个参数，第一个也就是fn是匿名化简函数，{}是初始值，words是集合。reduce将为集合中的每一个元素都调用一次化简函数。接着，我们看fn函数，需要两个参数counts和word，counts是一个map，(get counts word 0)返回counts中word对应的个数，inc()接受这个值并加1，assoc()更新counts中word的值。这个就是简单的词频统计，下一步是将其与XML结合，统计其中词频。 话不多说，还是直接上代码。 123(defn get-words [text] (re-seq #&quot;\\w+&quot; text))(defn count-words-sequential [pages](frequencies (mapcat get-words pages))) get-words函数是利用正则表达式将text切割成词的序列。对一个字符串序列进行映射，会得到一个二维序列。要得到一维序列，这就是mapcat的功能。 值得注意的是，Clojure中序列是懒惰的，也就是说只有在当使用时，元素才会被求值。所以，在面对大数据量，如40GB大小的文件，也完全可以处理。 2、函数式并行 map函数，接受一个函数f和一个序列，返回一个新的序列，将序列中的每一个元素的值作为f的参数，f的返回值则成新序列的对应元素。partial函数，接受一个函数和若干参数，返回一个被局部代入的函数。如：(partial * 2) 2 等于4。而Clojure中提供了功能类似于map的pmap函数，将处理过程并行化。merge-with函数将maps中其余的map合并到第一个map中。 show you the code: 12(defn count-words-parallel [pages](reduce (partial merge-with +) (pmap #(frequencies (get-words %)) pages))) note: #(frequencies (get-words %)) 等价于 (fn [page] (frequencies (get-words page))) 但是，通过实验，这里的效率提升其实并不理想。我们可以注意到，这里reduce将对每一页都调用一次合并函数，而这样计数与合并将导致大量开销。所以，可以采用批处理操作，一次处理100页。partition-all函数就提供了这样的功能，将序列中的元素分批，构成多个序列。改进后的代码如下： 1(defn count-words [pages] (reduce (partial merge-with +) (pmap count-words-sequential (partition-all 100 pages)))) 另外，补充一点，Clojure中有个fold函数实现了二分算法，可以将分组结果两两化简，直到剩下一个最终的结果。 3、函数式并发 在Java等命令式语言中，一般来说，求值顺序与其在代码中的顺序基本是一致的。但函数式语言如何安排求值顺序则是相对自由的。 在纯粹的函数式语言中，函数都具有引用透明性————在任何调用函数的地方，都可以用函数运行的结果来替代函数的调用，而不会对程序产生副作用。考虑下面这个代码，(+ 1 2)和(+ 3 4)的计算顺序与结果没有关系，完全可以同时执行。这种执行方式称为数据流式编程，Clojure提供了future模型和promise模型来支持这种执行方式。 1(+ (+ 1 2) (+ 3 4)) Future模型 future就要提到future函数，future接受一段代码，并在一个单独的线程中执行，并返回一个对象，可以用deref或@来获取对象的值。对future对象解引用时，将阻塞当前线程，直到其代表的值变得可用。所以，前面求和的代码就变成这样： 1user=&gt; (let [a (future (+ 1 2)) b (future (+ 3 4))] (+ @a @b)) let将求和结果赋值给a,b，然后求和。 Promise模型 promise模型也类似。但是使用promise对象的代码不会立即执行，直到其被赋值。 1234567user=&gt; (def life (promise))#&apos;user/lifeuser=&gt; (future (println &quot;The meaning of life is:&quot; @life))#&lt;core$future_call$reify_6110@224e59d9: :pending&gt;user=&gt; (deliver life 27)#&lt;core$promise$reify_6153@52c9f3c7: 27&gt;The meaning of life is: 27 其中，利用future函数创建线程是Clojure的惯例。 在Java8中，利用有名的lambda表达式和stream API可以写出函数式代码。 以上。","categories":[],"tags":[{"name":"七周七并发","slug":"七周七并发","permalink":"http://orzn.github.io/tags/七周七并发/"}]},{"title":"七周七并发之线程与锁","slug":"七周七并发之一","date":"2017-08-17T15:39:27.000Z","updated":"2017-08-22T12:13:21.436Z","comments":true,"path":"2017/08/17/七周七并发之一/","link":"","permalink":"http://orzn.github.io/2017/08/17/七周七并发之一/","excerpt":"","text":"线程与锁模型其实是对底层硬件运行过程的形式化。这种形式化既是该模型最大的优点也是它最大的缺点。 1、 互斥和内存模型 Java中，并发的基本单元是线程，可以将线程看作控制流。线程共享内存进行通信。线程的helloword版需要包括： 1234mythread.start();Thread.yield();System.out.println(\"hello world!\");mythread.join(); yield()的作用是通知调度器：当前线程想要让出对处理器的占用。如果不调用，则syso则几乎肯定会先执行。join()的作用是等待mythread线程执行完。当有多个线程对同一资源竞争时，解决方案就是进行同步（synchronize）访问。一种方法就是使用java的内置锁（也称为互斥锁、管城或临界区）。比如，我们要竞争的是一个函数increment()，那么在定义这个函数的时候就需要这样定义：1public synchronized void increment() &#123; ++count; &#125; 值得注意的是，线程执行过程中完全可能出现乱序执行。包括编译器的静态优化，JVM的动态优化，硬件的优化。这一部分有待进一步了解。随着近几年运行效率的提升，尤其是共享内存架构的运行效率提升，都仰仗于此类代码优化。显然，需要有明确的标准告诉我们，这就是Java内存模型。 Java内存模型定义了何时一个线程对内存的修改对另一个线程可见。基本原则是，如果读线程和写线程不进行同步，就不能保证可见性。 对共享变量的所有访问都需要同步化； 读写线程都需要同步化； 按照约定顺序来获取多把锁； 持有锁时避免调用外星方法； 持有锁的时间应尽可能短。 2、 超越内置锁 Java的内置锁是过去很长时间内，Java对并发编程提供的全部支持。Java5之后引入了java.util.concurrent包改善了这种状况，今天我们将学习这种增强的锁机制。 ReentrantLock提供了显示的lock和unlock方法。基本使用方法如下： 1234567Lock lock = new ReentrantLock();lock.lock();try&#123; //使用共享资源&#125;finally&#123; lock.unlock();&#125; ReentrantLock的好处之一就是可中断。当内置锁因争抢资源而死锁时，可用ReentrantLock的lockInterruptibly()方法。这里先留个坑。 ReentrantLock的好处之二就是设置超时时间。tryLock()提供了这个功能，在获取锁失败时有超时机制。 ReentrantLock的好处之三就是交替锁。对于一链表，当想插入一节点时，将两边两个节点锁住，然后插入。 ReentrantLock的好处之四就是条件变量。一个条件变量需要与一把锁关联，线程在开始等待条件前必须获取这把锁。获取锁后，检查所等待条件或否已经为真。如果条件为真，线程将解锁并继续执行；如果条件不为真，线程会调用await(),它将原子的解锁并阻塞等待该条件。 ReentrantLock的好处之四就是原子变量。举个栗子： 12final AtomicInteger counter = new AtomicInteger();counter.incrementAndGet(); 这里调用incrementAndGet函数，就不用担心getCount()时，忘了同步而引发的Counter内存可见性问题。其次，没有锁的参与，对原子变量的操作不会引发死锁。 3、 concurrent包 concurrent包提供了一些比内置锁更好的锁，更通用、高效、bug少的并发数据结构和工具。 123456int threadPoolSize = Runtime.getRuntime.availableProcessors()*2;ExecutorService executor = Executors.newFixedThreadPool();while(true)&#123; Socket socket = server.accept(); executor.execute(new ConnectionHandler(socket));&#125; 上面的代码，创建一个线程池，线程池的大小可以设为处理器数的两倍，如果同一时间有超过线程池大小的execute()请求存在，超出的部分将进行排队直到某线程被释放。这样，不必为每个连接都消耗资源来创建线程。影响线程池最优大小的因素有很多，但也存在经验法则，对于CPU密集型的任务，线程池大小应接近于可用核数；对于IO密集型的任务，线程池可以设置得更大。 举个例子——词频统计 词频统计需要完成了这两个任务，解析XML并构造一个Page，然后“消费”这个page，对page中的内容统计词频。这种问题，就可以归为——生产者-消费者模式。 生产者 12345678910111213class Parser implements Runnable&#123; private BlockingQueue&lt;Page&gt; queue; public Parser(BlockingQueue&lt;Page&gt; queue)&#123; this.queue = queue; &#125; public void run()&#123; try&#123; Iterable&lt;Page&gt; pages = new Pages(100000, &quot;enwiki.xml&quot;); for(Page page: pages) queue.put(page); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 消费者 1234567891011121314151617181920class Counter implements Runnable&#123; private BlockingQueue&lt;Page&gt; queue; private Map&lt;String,Integer&gt; counts; public Parser(BlockingQueue&lt;Page&gt; queue,Map&lt;String,Integer&gt; counts)&#123; this.queue = queue; this.counts = counts; &#125; public void run()&#123; try&#123; while(true)&#123; Page page = queue.take(); if(page.isPoisonPill()) break; Iterable&lt;String&gt; words = new Words(page.getText()); for(String word:words) countWord(word); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 主程序如下： 12345678910ArrayBlockingQueue&lt;Page&gt; queue = new ArrayBlockingQueue&lt;Page&gt;(100);HashMap&lt;String,Integer&gt; counts = new HashMap&lt;String,Integer&gt;();Thread counter = new Thread(new Counter(queue,counts));Thread parser = new Thread(new Parser(queue));counter.start();parser.start();parser.join();queue.put(new PoisonPill());counter.join(); 使用concurrent包就很方便，像ArrayBlockingQueue就是中间提供的一种并发队列，提供了高效的并发方法put和take，细节就不用管。使用阻塞队列是为了防止生产者生产速度过快，消费者跟不上。 以上。","categories":[],"tags":[{"name":"七周七并发","slug":"七周七并发","permalink":"http://orzn.github.io/tags/七周七并发/"}]},{"title":"Java ConcurrentModificationException","slug":"java","date":"2017-05-18T14:26:32.003Z","updated":"2017-05-18T16:31:33.599Z","comments":true,"path":"2017/05/18/java/","link":"","permalink":"http://orzn.github.io/2017/05/18/java/","excerpt":"","text":"1. 出现原因 具体源码就不剖析了，直接说结果。原因是调用list.remove()方法导致modCount和expectedModCount的值不一致。注意，像使用for-each进行迭代实际上也会出现这种问题。所以，在迭代的过程中就不要使用list.remove()方法。 2. 单线程环境下的解决办法 既然知道原因了，那么如何解决呢？ 其实很简单，细心的朋友可能发现在Itr类中也给出了一个remove()方法： 123456789101112131415public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125;&#125; 在这个方法中，删除元素实际上调用的就是list.remove()方法，但是它多了一个操作： 1expectedModCount = modCount; 因此，在迭代器中如果要删除元素的话，需要调用Itr类的remove方法。 将上述代码改为下面这样就不会报错了： 123456789101112public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer==2) iterator.remove(); //注意这个地方 &#125; &#125;&#125; 3. 多线程环境下的解决办法 一般有2种解决办法： 1. 在使用iterator迭代的时候使用synchronized或者Lock进行同步； 2. 使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://orzn.github.io/tags/java/"}]},{"title":"markov","slug":"markov","date":"2017-05-17T15:39:27.000Z","updated":"2017-05-19T15:23:05.762Z","comments":true,"path":"2017/05/17/markov/","link":"","permalink":"http://orzn.github.io/2017/05/17/markov/","excerpt":"","text":"马尔科夫也是一个经常遇到的名词了，马尔科夫过程，马尔科夫随机场等等，了解过，但一知半解，仍不是很理解，趁着学习图像处理这门课，把这些相关的东西也好好学学，整理整理。 马尔可夫链，因安德烈·马尔可夫（A.A.Markov，1856－1922）得名，是指数学中具有马尔可夫性质的离散事件随机过程。该过程中，在给定当前知识或信息的情况下，过去（即当前以前的历史状态）对于预测将来（即当前以后的未来状态）是无关的。随机漫步就是马尔可夫链的例子。其满足下面这个式子： 而马尔科夫过程呢，实际和马尔科夫链是一回事，只不过马尔科夫链是一个离散事件。 要说马尔科夫随机场，还需要先明确随机场的概念。随机场包含两个要素：位置（site），相空间（phase space）。当给每一个位置中按照某种分布随机赋予相空间的一个值之后，其全体就叫做随机场。我们不妨拿种地来打个比方。“位置”好比是一亩亩农田；“相空间”好比是种的各种庄稼。我们可以给不同的地种上不同的庄稼，这就好比给随机场的每个“位置”，赋予相空间里不同的值。所以，俗气点说，随机场就是在哪块地里种什么庄稼的事情。那么什么是马尔可夫随机场呢？还是拿种地打比方，如果任何一块地里种的庄稼的种类仅仅与它邻近的地里种的庄稼的种类有关，与其它地方的庄稼的种类无关，那么这些地里种的庄稼的集合，就是一个马尔可夫随机场。 要严格定义马尔科夫随机场，还需要引入邻域系统的的概念。 其实看了这幅图之后，不用细讲，也会大概明白邻域系统是个什么东西。在具体应用中，选取以x为中心，多大范围内的点为x的相邻像素点，不是固定不变的。X周围紫色的一圈称为4邻域系统，周围的所有8个点称为8邻域系统。令F={F1,…..,Fm}是一组定义在集合S上的随机变量，假如邻域系统中，对于任一点X，其取值只与邻域有关，那么我们就可以称F是一个马尔科夫随机场。 用马尔科夫随机场模型来解决实际问题时，如图像切割时，往往会用到马尔科夫随机场。","categories":[],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"http://orzn.github.io/tags/图像处理/"}]},{"title":"markdown","slug":"markdown","date":"2017-05-09T05:09:16.000Z","updated":"2017-05-09T05:36:23.881Z","comments":true,"path":"2017/05/09/markdown/","link":"","permalink":"http://orzn.github.io/2017/05/09/markdown/","excerpt":"","text":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。当然，我使用这个主要是因为github的锅。别的不多说了，这里简单介绍一些Markdown的基本语法： 1. 标题 对于标题，有两种写法：Setext和atx形式。Setext形式是利用底线的形式，利用=（最高阶标题）和-（第二节标题）；Atx形式是在行首插入1到6个#，对应标题1到6阶。 Setext形式：A First Level Header =（几个等于号都行） A Second Level Header - A First Level Header=A Second Level Header- 经测试，好像Setex并不靠谱。。。 Atx形式：#A First Level Header ##A Second Level Header A First Level HeaderA Second Level Header2. 段落 想要分段需要在两个段落中间加入一个以上的空行。或者可以在上一个段末加上两个空格。不过，效果不同。 This is a paragraph. This is the second paragraph This is a paragraph. This is the second paragraph This is a paragraph.(space)(space) This is the second paragraph This is a paragraph.This is the second paragraph 3. 粗斜体 粗体，斜体也经常会用到。斜体就是文本两端加上＊或者＿，而粗体是在两边各加两个，粗斜体是加三个。 *斜体文本* _斜体文本_ 斜体文本 斜体文本 **粗体文本** __粗体文本__ 粗体文本 粗体文本 ***粗斜体文本*** ___粗斜体文本___ 粗斜体文本 粗斜体文本 4. 列表无序列表以下三种写法都行： - 列表文本前使用 [减号+空格] + 列表文本前使用 [加号+空格] * 列表文本前使用 [星号+空格] 列表文本前使用 [减号+空格] 列表文本前使用 [加号+空格] 列表文本前使用 [星号+空格] 有序列表注意： 数字后面有个点. 1. 列表前使用 [数字+空格] 2. 我们会自动帮你添加数字 7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 列表前使用 [数字+空格] 我们会自动帮你添加数字 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 除了普通的列表以外，我们也许还会用到列表的嵌套，这时候，只需要在前面加上四个空格。 5. 链接常用的链接方法：文字链接 [this is my hourse](http://www.orzn.ml) 网址链接 &lt;http://www.orzn.ml&gt; 文字链接 this is my hourse 网址链接 http://www.orzn.ml 高级链接方法：这个链接用 1 作为网址变量 [Google][1].这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo]. 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ 这个链接用 1 作为网址变量 Google.这个链接用 yahoo 作为网址变量 Yahoo!.然后在文档的结尾为变量赋值（网址） 以上两种写法显示效果是一样的，第二种方法在文档的结尾所写的网址，也不会显示。 6. 图片 跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？也可以使用 HTML 的图片语法来自定义图片的宽高大小: &lt;img src=&quot;http://ww4.sinaimg.cn/mw690/7b405dbbgw1e9ko16tk6dj20pc0fuwhw.jpg&quot; width=&quot;400&quot; height=&quot;100&quot;&gt; 7. 代码 想要在文中高亮语句中的某个函数名或关键字，可以使用 `function_name()` 实现function_name()。如果是代码段，可以用12345```javascript$(document).ready(function () &#123; alert(&apos;hello world&apos;);&#125;); 123$(document).ready(function () &#123; alert('hello world');&#125;); PS: 如果你的描述中需要用到 markdown 的符号，比如 # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 \\ \\# \\* 进行避免。 目前只支持部分段内 HTML 元素效果，包括&lt;kdb&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;当然，前面提到的img也是。 markdown里面段落前是不能空两格的，我们可以将输入法调成全角，然后在段首敲两个空格键就可以了。","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://orzn.github.io/tags/markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-07T16:50:17.733Z","updated":"2017-05-08T04:48:35.899Z","comments":true,"path":"2017/05/08/hello-world/","link":"","permalink":"http://orzn.github.io/2017/05/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}