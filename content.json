{"meta":{"title":"orzn","subtitle":"兴趣使然","description":"望你走出半生，归来仍是少年","author":"John Doe","url":"http://orzn.github.io"},"pages":[],"posts":[{"title":"Java ConcurrentModificationException","slug":"java","date":"2017-05-18T14:26:32.003Z","updated":"2017-05-18T16:31:33.599Z","comments":true,"path":"2017/05/18/java/","link":"","permalink":"http://orzn.github.io/2017/05/18/java/","excerpt":"","text":"1. 出现原因 具体源码就不剖析了，直接说结果。原因是调用list.remove()方法导致modCount和expectedModCount的值不一致。注意，像使用for-each进行迭代实际上也会出现这种问题。所以，在迭代的过程中就不要使用list.remove()方法。 2. 单线程环境下的解决办法 既然知道原因了，那么如何解决呢？ 其实很简单，细心的朋友可能发现在Itr类中也给出了一个remove()方法： 123456789101112131415public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125;&#125; 在这个方法中，删除元素实际上调用的就是list.remove()方法，但是它多了一个操作： 1expectedModCount = modCount; 因此，在迭代器中如果要删除元素的话，需要调用Itr类的remove方法。 将上述代码改为下面这样就不会报错了： 123456789101112public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer==2) iterator.remove(); //注意这个地方 &#125; &#125;&#125; 3. 多线程环境下的解决办法 一般有2种解决办法： 1. 在使用iterator迭代的时候使用synchronized或者Lock进行同步； 2. 使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://orzn.github.io/tags/java/"}]},{"title":"markov","slug":"markov","date":"2017-05-17T15:39:27.000Z","updated":"2017-05-19T15:23:05.762Z","comments":true,"path":"2017/05/17/markov/","link":"","permalink":"http://orzn.github.io/2017/05/17/markov/","excerpt":"","text":"马尔科夫也是一个经常遇到的名词了，马尔科夫过程，马尔科夫随机场等等，了解过，但一知半解，仍不是很理解，趁着学习图像处理这门课，把这些相关的东西也好好学学，整理整理。 马尔可夫链，因安德烈·马尔可夫（A.A.Markov，1856－1922）得名，是指数学中具有马尔可夫性质的离散事件随机过程。该过程中，在给定当前知识或信息的情况下，过去（即当前以前的历史状态）对于预测将来（即当前以后的未来状态）是无关的。随机漫步就是马尔可夫链的例子。其满足下面这个式子： 而马尔科夫过程呢，实际和马尔科夫链是一回事，只不过马尔科夫链是一个离散事件。 要说马尔科夫随机场，还需要先明确随机场的概念。随机场包含两个要素：位置（site），相空间（phase space）。当给每一个位置中按照某种分布随机赋予相空间的一个值之后，其全体就叫做随机场。我们不妨拿种地来打个比方。“位置”好比是一亩亩农田；“相空间”好比是种的各种庄稼。我们可以给不同的地种上不同的庄稼，这就好比给随机场的每个“位置”，赋予相空间里不同的值。所以，俗气点说，随机场就是在哪块地里种什么庄稼的事情。那么什么是马尔可夫随机场呢？还是拿种地打比方，如果任何一块地里种的庄稼的种类仅仅与它邻近的地里种的庄稼的种类有关，与其它地方的庄稼的种类无关，那么这些地里种的庄稼的集合，就是一个马尔可夫随机场。 要严格定义马尔科夫随机场，还需要引入邻域系统的的概念。 其实看了这幅图之后，不用细讲，也会大概明白邻域系统是个什么东西。在具体应用中，选取以x为中心，多大范围内的点为x的相邻像素点，不是固定不变的。X周围紫色的一圈称为4邻域系统，周围的所有8个点称为8邻域系统。令F={F1,…..,Fm}是一组定义在集合S上的随机变量，假如邻域系统中，对于任一点X，其取值只与邻域有关，那么我们就可以称F是一个马尔科夫随机场。 用马尔科夫随机场模型来解决实际问题时，如图像切割时，往往会用到马尔科夫随机场。","categories":[],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"http://orzn.github.io/tags/图像处理/"}]},{"title":"七周七并发之线程与锁","slug":"七周七并发之一","date":"2017-05-17T15:39:27.000Z","updated":"2017-08-22T07:52:28.126Z","comments":true,"path":"2017/05/17/七周七并发之一/","link":"","permalink":"http://orzn.github.io/2017/05/17/七周七并发之一/","excerpt":"","text":"线程与锁模型其实是对底层硬件运行过程的形式化。这种形式化既是该模型最大的优点也是它最大的缺点。 1、 互斥和内存模型 Java中，并发的基本单元是线程，可以将线程看作控制流。线程共享内存进行通信。线程的helloword版需要包括： 1234mythread.start();Thread.yield();System.out.println(\"hello world!\");mythread.join(); yield()的作用是通知调度器：当前线程想要让出对处理器的占用。如果不调用，则syso则几乎肯定会先执行。join()的作用是等待mythread线程执行完。当有多个线程对同一资源竞争时，解决方案就是进行同步（synchronize）访问。一种方法就是使用java的内置锁（也称为互斥锁、管城或临界区）。比如，我们要竞争的是一个函数increment()，那么在定义这个函数的时候就需要这样定义：1public synchronized void increment() &#123; ++count; &#125; 值得注意的是，线程执行过程中完全可能出现乱序执行。包括编译器的静态优化，JVM的动态优化，硬件的优化。这一部分有待进一步了解。随着近几年运行效率的提升，尤其是共享内存架构的运行效率提升，都仰仗于此类代码优化。显然，需要有明确的标准告诉我们，这就是Java内存模型。 Java内存模型定义了何时一个线程对内存的修改对另一个线程可见。基本原则是，如果读线程和写线程不进行同步，就不能保证可见性。 对共享变量的所有访问都需要同步化； 读写线程都需要同步化； 按照约定顺序来获取多把锁； 持有锁时避免调用外星方法； 持有锁的时间应尽可能短。 2、 超越内置锁 Java的内置锁是过去很长时间内，Java对并发编程提供的全部支持。Java5之后引入了java.util.concurrent包改善了这种状况，今天我们将学习这种增强的锁机制。 ReentrantLock提供了显示的lock和unlock方法。基本使用方法如下： 1234567Lock lock = new ReentrantLock();lock.lock();try&#123; //使用共享资源&#125;finally&#123; lock.unlock();&#125; ReentrantLock的好处之一就是可中断。当内置锁因争抢资源而死锁时，可用ReentrantLock的lockInterruptibly()方法。这里先留个坑。 ReentrantLock的好处之二就是设置超时时间。tryLock()提供了这个功能，在获取锁失败时有超时机制。 ReentrantLock的好处之三就是交替锁。对于一链表，当想插入一节点时，将两边两个节点锁住，然后插入。 ReentrantLock的好处之四就是条件变量。一个条件变量需要与一把锁关联，线程在开始等待条件前必须获取这把锁。获取锁后，检查所等待条件或否已经为真。如果条件为真，线程将解锁并继续执行；如果条件不为真，线程会调用await(),它将原子的解锁并阻塞等待该条件。 ReentrantLock的好处之四就是原子变量。举个栗子： 12final AtomicInteger counter = new AtomicInteger();counter.incrementAndGet(); 这里调用incrementAndGet函数，就不用担心getCount()时，忘了同步而引发的Counter内存可见性问题。其次，没有锁的参与，对原子变量的操作不会引发死锁。 3、 concurrent包 concurrent包提供了一些比内置锁更好的锁，更通用、高效、bug少的并发数据结构和工具。 123456int threadPoolSize = Runtime.getRuntime.availableProcessors()*2;ExecutorService executor = Executors.newFixedThreadPool();while(true)&#123; Socket socket = server.accept(); executor.execute(new ConnectionHandler(socket));&#125; 上面的代码，创建一个线程池，线程池的大小可以设为处理器数的两倍，如果同一时间有超过线程池大小的execute()请求存在，超出的部分将进行排队直到某线程被释放。这样，不必为每个连接都消耗资源来创建线程。影响线程池最优大小的因素有很多，但也存在经验法则，对于CPU密集型的任务，线程池大小应接近于可用核数；对于IO密集型的任务，线程池可以设置得更大。 举个例子——词频统计 词频统计需要完成了这两个任务，解析XML并构造一个Page，然后“消费”这个page，对page中的内容统计词频。这种问题，就可以归为——生产者-消费者模式。 生产者 12345678910111213class Parser implements Runnable&#123; private BlockingQueue&lt;Page&gt; queue; public Parser(BlockingQueue&lt;Page&gt; queue)&#123; this.queue = queue; &#125; public void run()&#123; try&#123; Iterable&lt;Page&gt; pages = new Pages(100000, &quot;enwiki.xml&quot;); for(Page page: pages) queue.put(page); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 消费者 1234567891011121314151617181920class Counter implements Runnable&#123; private BlockingQueue&lt;Page&gt; queue; private Map&lt;String,Integer&gt; counts; public Parser(BlockingQueue&lt;Page&gt; queue,Map&lt;String,Integer&gt; counts)&#123; this.queue = queue; this.counts = counts; &#125; public void run()&#123; try&#123; while(true)&#123; Page page = queue.take(); if(page.isPoisonPill()) break; Iterable&lt;String&gt; words = new Words(page.getText()); for(String word:words) countWord(word); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 主程序如下： 12345678910ArrayBlockingQueue&lt;Page&gt; queue = new ArrayBlockingQueue&lt;Page&gt;(100);HashMap&lt;String,Integer&gt; counts = new HashMap&lt;String,Integer&gt;();Thread counter = new Thread(new Counter(queue,counts));Thread parser = new Thread(new Parser(queue));counter.start();parser.start();parser.join();queue.put(new PoisonPill());counter.join(); 使用concurrent包就很方便，像ArrayBlockingQueue就是中间提供的一种并发队列，提供了高效的并发方法put和take，细节就不用管。使用阻塞队列是为了防止生产者生产速度过快，消费者跟不上。 以上。","categories":[],"tags":[{"name":"七周七并发","slug":"七周七并发","permalink":"http://orzn.github.io/tags/七周七并发/"}]},{"title":"七周七并行之函数式编程","slug":"七周七并发之二","date":"2017-05-17T15:39:27.000Z","updated":"2017-08-22T11:39:43.559Z","comments":true,"path":"2017/05/17/七周七并发之二/","link":"","permalink":"http://orzn.github.io/2017/05/17/七周七并发之二/","excerpt":"","text":"提到函数式编程，就要提到命令式编程。常见的C，Java都是命令式编程，代码由一些列改变全局状态的语句过程，而函数式编程则是将计算过程抽象成表达式求值。轮子哥是这么形容函数式语言的，“函数是语言都倾向于让你用函数来组成函数，而不是把函数看成是一个数据弄成另一个数据的过程。”函数式编程可以更容易做到线程安全，因此特别适合于并发编程。 1、抛弃可变状态 函数式编程里，没有可变状态。为了体验函数式编程，这里介绍下Clojure。Clojure是一种运行在Java平台上的 Lisp 方言，Lisp是一种以表达性和功能强大著称的编程语言，但人们通常认为它不太适合应用于一般情况，而Clojure的出现彻底改变了这一现状。如今，在任何具备 Java 虚拟机的地方，您都可以利用 Lisp 的强大功能。 Clojure代码由s-表达式过构成。可以将表达式视为带括号的列表。主流语言中的max(3,5)在Clojure中写作： 1user=&gt; (max 3 5) 数学运算符也是同样的表示方式。比如1+2*3，写成： 1user=&gt; (+ 1 (* 2 3)) 使用def可以定义常量： 1234user=&gt; (def meaning-of-life 42)#&apos;user/meaning-of-lifeuser=&gt; meaning-of-life42 控制结构也可以写成s-表达式： 12user=&gt; (if (&lt; meaning-of-life 0) &quot;negative&quot; &quot;non-negative&quot;)&quot;non-negative&quot; Clojure的大多数语句都是一个s-表达式，然而也有个别例外。矢量（数组）是用方括号表示： 12345678user=&gt; (def droids [&quot;a&quot; &quot;b&quot; &quot;c&quot;])#&apos;user/droidsuser=&gt; (count droids)3user=&gt; (droids 0)&quot;a&quot;user=&gt; (droids 2)&quot;c&quot; map是用花括号表示： 1234user=&gt; (def me &#123;:name &quot;Paul&quot; :age 45 :sex :male&#125;)#&apos;user/meuser=&gt; (:age me)45 使用defn可以定义函数，函数参数是矢量形式的： 1234user=&gt; (defn percentage [x p] (* x (/ p 100.0)))#&apos;user/percentageuser=&gt; (percentage 200 10)20.0 举个例子——词频统计 先给出代码： 12345(defn word-frequencies [words](reduce (fn [counts word] (assoc counts word (inc (get counts word 0))))&#123;&#125; words)) defn定义一个函数，所有外面有一个大括号，words是参数，里面的()就是函数体，reduce是Clojure中一个函数，需要三个参数，第一个也就是fn是匿名化简函数，{}是初始值，words是集合。reduce将为集合中的每一个元素都调用一次化简函数。接着，我们看fn函数，需要两个参数counts和word，counts是一个map，(get counts word 0)返回counts中word对应的个数，inc()接受这个值并加1，assoc()更新counts中word的值。这个就是简单的词频统计，下一步是将其与XML结合，统计其中词频。 话不多说，还是直接上代码。 123(defn get-words [text] (re-seq #&quot;\\w+&quot; text))(defn count-words-sequential [pages](frequencies (mapcat get-words pages))) get-words函数是利用正则表达式将text切割成词的序列。对一个字符串序列进行映射，会得到一个二维序列。要得到一维序列，这就是mapcat的功能。 值得注意的是，Clojure中序列是懒惰的，也就是说只有在当使用时，元素才会被求值。所以，在面对大数据量，如40GB大小的文件，也完全可以处理。 2、函数式并行 map函数，接受一个函数f和一个序列，返回一个新的序列，将序列中的每一个元素的值作为f的参数，f的返回值则成新序列的对应元素。partial函数，接受一个函数和若干参数，返回一个被局部代入的函数。如：(partial * 2) 2 等于4。而Clojure中提供了功能类似于map的pmap函数，将处理过程并行化。merge-with函数将maps中其余的map合并到第一个map中。 show you the code: 12(defn count-words-parallel [pages](reduce (partial merge-with +) (pmap #(frequencies (get-words %)) pages))) note: #(frequencies (get-words %)) 等价于 (fn [page] (frequencies (get-words page))) 但是，通过实验，这里的效率提升其实并不理想。我们可以注意到，这里reduce将对每一页都调用一次合并函数，而这样计数与合并将导致大量开销。所以，可以采用批处理操作，一次处理100页。partition-all函数就提供了这样的功能，将序列中的元素分批，构成多个序列。改进后的代码如下： 1(defn count-words [pages] (reduce (partial merge-with +) (pmap count-words-sequential (partition-all 100 pages)))) 另外，补充一点，Clojure中有个fold函数实现了二分算法，可以将分组结果两两化简，直到剩下一个最终的结果。 3、函数式并发 在Java等命令式语言中，一般来说，求值顺序与其在代码中的顺序基本是一致的。但函数式语言如何安排求值顺序则是相对自由的。 在纯粹的函数式语言中，函数都具有引用透明性————在任何调用函数的地方，都可以用函数运行的结果来替代函数的调用，而不会对程序产生副作用。考虑下面这个代码，(+ 1 2)和(+ 3 4)的计算顺序与结果没有关系，完全可以同时执行。这种执行方式称为数据流式编程，Clojure提供了future模型和promise模型来支持这种执行方式。 1(+ (+ 1 2) (+ 3 4)) Future模型 future就要提到future函数，future接受一段代码，并在一个单独的线程中执行，并返回一个对象，可以用deref或@来获取对象的值。对future对象解引用时，将阻塞当前线程，直到其代表的值变得可用。所以，前面求和的代码就变成这样： 1user=&gt; (let [a (future (+ 1 2)) b (future (+ 3 4))] (+ @a @b)) let将求和结果赋值给a,b，然后求和。 Promise模型 promise模型也类似。但是使用promise对象的代码不会立即执行，直到其被赋值。 1234567user=&gt; (def life (promise))#&apos;user/lifeuser=&gt; (future (println &quot;The meaning of life is:&quot; @life))#&lt;core$future_call$reify_6110@224e59d9: :pending&gt;user=&gt; (deliver life 27)#&lt;core$promise$reify_6153@52c9f3c7: 27&gt;The meaning of life is: 27 其中，利用future函数创建线程是Clojure的惯例。 在Java8中，利用有名的lambda表达式和stream API可以写出函数式代码。 以上。","categories":[],"tags":[{"name":"七周七并发","slug":"七周七并发","permalink":"http://orzn.github.io/tags/七周七并发/"}]},{"title":"markdown","slug":"markdown","date":"2017-05-09T05:09:16.000Z","updated":"2017-05-09T05:36:23.881Z","comments":true,"path":"2017/05/09/markdown/","link":"","permalink":"http://orzn.github.io/2017/05/09/markdown/","excerpt":"","text":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。当然，我使用这个主要是因为github的锅。别的不多说了，这里简单介绍一些Markdown的基本语法： 1. 标题 对于标题，有两种写法：Setext和atx形式。Setext形式是利用底线的形式，利用=（最高阶标题）和-（第二节标题）；Atx形式是在行首插入1到6个#，对应标题1到6阶。 Setext形式：A First Level Header =（几个等于号都行） A Second Level Header - A First Level Header=A Second Level Header- 经测试，好像Setex并不靠谱。。。 Atx形式：#A First Level Header ##A Second Level Header A First Level HeaderA Second Level Header2. 段落 想要分段需要在两个段落中间加入一个以上的空行。或者可以在上一个段末加上两个空格。不过，效果不同。 This is a paragraph. This is the second paragraph This is a paragraph. This is the second paragraph This is a paragraph.(space)(space) This is the second paragraph This is a paragraph.This is the second paragraph 3. 粗斜体 粗体，斜体也经常会用到。斜体就是文本两端加上＊或者＿，而粗体是在两边各加两个，粗斜体是加三个。 *斜体文本* _斜体文本_ 斜体文本 斜体文本 **粗体文本** __粗体文本__ 粗体文本 粗体文本 ***粗斜体文本*** ___粗斜体文本___ 粗斜体文本 粗斜体文本 4. 列表无序列表以下三种写法都行： - 列表文本前使用 [减号+空格] + 列表文本前使用 [加号+空格] * 列表文本前使用 [星号+空格] 列表文本前使用 [减号+空格] 列表文本前使用 [加号+空格] 列表文本前使用 [星号+空格] 有序列表注意： 数字后面有个点. 1. 列表前使用 [数字+空格] 2. 我们会自动帮你添加数字 7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 列表前使用 [数字+空格] 我们会自动帮你添加数字 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 除了普通的列表以外，我们也许还会用到列表的嵌套，这时候，只需要在前面加上四个空格。 5. 链接常用的链接方法：文字链接 [this is my hourse](http://www.orzn.ml) 网址链接 &lt;http://www.orzn.ml&gt; 文字链接 this is my hourse 网址链接 http://www.orzn.ml 高级链接方法：这个链接用 1 作为网址变量 [Google][1].这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo]. 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ 这个链接用 1 作为网址变量 Google.这个链接用 yahoo 作为网址变量 Yahoo!.然后在文档的结尾为变量赋值（网址） 以上两种写法显示效果是一样的，第二种方法在文档的结尾所写的网址，也不会显示。 6. 图片 跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？也可以使用 HTML 的图片语法来自定义图片的宽高大小: &lt;img src=&quot;http://ww4.sinaimg.cn/mw690/7b405dbbgw1e9ko16tk6dj20pc0fuwhw.jpg&quot; width=&quot;400&quot; height=&quot;100&quot;&gt; 7. 代码 想要在文中高亮语句中的某个函数名或关键字，可以使用 `function_name()` 实现function_name()。如果是代码段，可以用12345```javascript$(document).ready(function () &#123; alert(&apos;hello world&apos;);&#125;); 123$(document).ready(function () &#123; alert('hello world');&#125;); PS: 如果你的描述中需要用到 markdown 的符号，比如 # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 \\ \\# \\* 进行避免。 目前只支持部分段内 HTML 元素效果，包括&lt;kdb&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;当然，前面提到的img也是。 markdown里面段落前是不能空两格的，我们可以将输入法调成全角，然后在段首敲两个空格键就可以了。","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://orzn.github.io/tags/markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-07T16:50:17.733Z","updated":"2017-05-08T04:48:35.899Z","comments":true,"path":"2017/05/08/hello-world/","link":"","permalink":"http://orzn.github.io/2017/05/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}